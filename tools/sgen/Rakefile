#!/usr/bin/rake
require 'pathname'
require 'yaml'
require 'json'
require 'shellwords'
require 'net/http'
require 'uri'
require 'open3'
require 'fileutils'

if ENV['BUNDLE_GEMFILE'].nil?
  puts "\u{274C} Please use bundle exec"
  exit 1
end

## [ Constants ] ##############################################################

WORKSPACE = 'SGen'.freeze
SCHEME_NAME = 'sgen'.freeze
CONFIGURATION = 'Debug'.freeze
RELEASE_CONFIGURATION = 'Release'.freeze
POD_NAME = 'SGen'.freeze
MIN_XCODE_VERSION = 10.0

BUILD_DIR = File.absolute_path('./build')
RELEASE_DIR = File.absolute_path('./releases/download')
BIN_NAME = 'sgen'.freeze

## [ Utils ] ##################################################################

# Colorization support for Strings
#
class String
  # colorization
  FORMATTING = {
    # text styling
    bold: 1,
    faint: 2,
    italic: 3,
    underline: 4,
    # foreground colors
    black: 30,
    red: 31,
    green: 32,
    yellow: 33,
    blue: 34,
    magenta: 35,
    cyan: 36,
    white: 37,
    # background colors
    bg_black: 40,
    bg_red: 41,
    bg_green: 42,
    bg_yellow: 43,
    bg_blue: 44,
    bg_magenta: 45,
    bg_cyan: 46,
    bg_white: 47
  }.freeze

  # only enable formatting if terminal supports it
  if `tput colors`.chomp.to_i >= 8
    def format(*styles)
      styles.reduce('') { |r, s| r << "\e[#{FORMATTING[s]}m" } << "#{self}\e[0m"
    end
  else
    def format(*_styles)
      self
    end
  end
end

# Utility functions to run Xcode commands, extract versionning info and logs messages
#
class Utils
  COLUMN_WIDTHS = [45, 12]

  ## [ Run commands ] #########################################################

  # formatter types
  # :xcpretty  : through xcpretty and store in artifacts
  # :raw       : store in artifacts
  # :to_string : run using backticks and return output

  # run a command using xcrun and xcpretty if applicable
  def self.run(command, task, subtask = '', xcrun: false, formatter: :raw)
    commands = if xcrun
                 [*command].map { |cmd| "#{version_select} xcrun #{cmd}" }
               else
                 [*command]
               end
    case formatter
    when :xcpretty then xcpretty(commands, task, subtask)
    when :raw then plain(commands, task, subtask)
    when :to_string then `#{commands.join(' && ')}`
    else raise "Unknown formatter '#{formatter}'"
    end
  end

  ## [ Convenience Helpers ] ##################################################

  def self.defaults(args)
    bindir = Utils.path(args.bindir) || (Pathname.new(BUILD_DIR) + 'sgen/bin')
    fmkdir = Utils.path(args.fmkdir) || (bindir + '../lib')
    [bindir, fmkdir].map(&:expand_path)
  end

  def self.path(str)
    return nil if str.nil? || str.empty?
    Pathname.new(str)
  end

  def self.podspec_version(file)
    file += '.podspec' unless file.include?('.podspec')
    json, _, _ = Open3.capture3('bundle', 'exec', 'pod', 'ipc', 'spec', file)
    JSON.parse(json)['version']
  end

  # @returns An array containing the CFBundleVersion & CFBundleShortVersionString
  #          values for the Info.plist of the given library
  def self.plist_version(lib)
    require 'plist'
    plist = Plist.parse_xml("Sources/Info.plist")
    [plist['CFBundleVersion'], plist['CFBundleShortVersionString']]
  end

  ## [ Print info/errors ] ####################################################

  # print an info message
  def self.print_info(str)
    puts str.chomp.format(:green)
  end

  # print an info header
  def self.print_header(str)
    puts "== #{str.chomp} ==".format(:yellow, :bold)
  end
  
  # format an info message in a 2 column table
  def self.table_header(col1, col2)
    puts "| #{col1.ljust(COLUMN_WIDTHS[0])} | #{col2.ljust(COLUMN_WIDTHS[1])} |"
    puts "| #{'-' * COLUMN_WIDTHS[0]} | #{'-' * COLUMN_WIDTHS[1]} |"
  end

  # format an info message in a 2 column table
  def self.table_info(label, msg)
    puts "| #{label.ljust(COLUMN_WIDTHS[0])} | 👉  #{msg.ljust(COLUMN_WIDTHS[1]-4)} |"
  end

  # format a result message in a 2 column table
  def self.table_result(result, label, error_msg)
    if result
      puts "| #{label.ljust(COLUMN_WIDTHS[0])} | #{'✅'.ljust(COLUMN_WIDTHS[1]-1)} |"
    else
      puts "| #{label.ljust(COLUMN_WIDTHS[0])} | ❌  - #{error_msg.ljust(COLUMN_WIDTHS[1]-6)} |"
    end
    result
  end

  ## [ Private helper functions ] ##################################################

  # run a command, pipe output through 'xcpretty' and store the output in CI artifacts
  def self.xcpretty(cmd, task, subtask)
    name = (task.name + (subtask.empty? ? '' : "_#{subtask}")).gsub(/[:-]/, '_')
    command = [*cmd].join(' && \\' + "\n")

    if ENV['CIRCLECI']
      Rake.sh "set -o pipefail && (\\\n#{command} \\\n) | tee \"#{ENV['CIRCLE_ARTIFACTS']}/#{name}_raw.log\" | " \
        "bundle exec xcpretty --color --report junit --output \"#{ENV['CIRCLE_TEST_REPORTS']}/xcode/#{name}.xml\""
    elsif system('which xcpretty > /dev/null')
      Rake.sh "set -o pipefail && (\\\n#{command} \\\n) | bundle exec xcpretty -c"
    else
      Rake.sh command
    end
  end
  private_class_method :xcpretty

  # run a command and store the output in CI artifacts
  def self.plain(cmd, task, subtask)
    name = (task.name + (subtask.empty? ? '' : "_#{subtask}")).gsub(/[:-]/, '_')
    command = [*cmd].join(' && \\' + "\n")

    if ENV['CIRCLECI']
      Rake.sh "set -o pipefail && (#{command}) | tee \"#{ENV['CIRCLE_ARTIFACTS']}/#{name}_raw.log\""
    else
      Rake.sh command
    end
  end
  private_class_method :plain

  # select the xcode version we want/support
  def self.version_select
    @version_select ||= compute_developer_dir(MIN_XCODE_VERSION)
  end
  private_class_method :version_select

  # Return the "DEVELOPER_DIR=..." prefix to use in order to point to the best Xcode version
  #
  # @param [String|Float|Gem::Requirement] version_req
  #        The Xcode version requirement.
  #        - If it's a Float, it's converted to a "~> x.y" requirement
  #        - If it's a String, it's converted to a Gem::Requirement as is
  # @note If you pass a String, be sure to use "~> " in the string unless you really want
  #       to point to an exact, very specific version
  #
  def self.compute_developer_dir(version_req)
    version_req = Gem::Requirement.new("~> #{version_req}") if version_req.is_a?(Float)
    version_req = Gem::Requirement.new(version_req) unless version_req.is_a?(Gem::Requirement)
    # if current Xcode already fulfills min version don't force DEVELOPER_DIR=...
    current_xcode_version = `xcodebuild -version`.split("\n").first.match(/[0-9.]+/).to_s
    return '' if version_req.satisfied_by? Gem::Version.new(current_xcode_version)

    supported_versions = all_xcode_versions.select { |app| version_req.satisfied_by?(app[:vers]) }
    latest_supported_xcode = supported_versions.sort_by { |app| app[:vers] }.last

    # Check if it's at least the right version
    if latest_supported_xcode.nil?
      raise "\n[!!!] SGen requires Xcode #{version_req}, but we were not able to find it. " \
        "If it's already installed, either `xcode-select -s` to it, or update your Spotlight index " \
        "with 'mdimport /Applications/Xcode*'\n\n"
    end

    %(DEVELOPER_DIR="#{latest_supported_xcode[:path]}/Contents/Developer")
  end
  private_class_method :compute_developer_dir

  # @return [Array<Hash>] A list of { :vers => ... , :path => ... } hashes
  #                       of all Xcodes found on the machine using Spotlight
  def self.all_xcode_versions
    mdfind_xcodes, _, _ = Open3.capture3('mdfind', "kMDItemCFBundleIdentifier = 'com.apple.dt.Xcode'")
    xcodes = mdfind_xcodes.chomp.split("\n")
    xcodes.map do |path|
      { vers: Gem::Version.new(`mdls -name kMDItemVersion -raw "#{path}"`), path: path }
    end
  end
  private_class_method :all_xcode_versions

end

## [ Build Tasks ] ############################################################

namespace :cli do
  desc "Build the CLI binary and its frameworks as an app bundle\n" \
       "(in #{BUILD_DIR})"
  task :build, %i[bindir] do |task, args|
    (bindir, _) = Utils.defaults(args)

    Utils.print_header 'Building Binary'
    plist_file = (Pathname.new(BUILD_DIR) + "Build/Products/#{RELEASE_CONFIGURATION}/sgen.app/Contents/Info.plist").to_s
    Utils.run(
      %(xcodebuild -workspace "#{WORKSPACE}.xcworkspace" -scheme "#{SCHEME_NAME}" -configuration "#{RELEASE_CONFIGURATION}") +
      %( -derivedDataPath "#{BUILD_DIR}") +
      %( SGEN_OTHER_LDFLAGS="-sectcreate __TEXT __info_plist #{plist_file.shellescape}"),
      task, xcrun: true, formatter: :xcpretty
    )
  end

  desc "Install the binary in $bindir, frameworks in $fmkdir\n" \
       '(defaults $bindir=./build/sgen/bin/, $fmkdir=$bindir/../lib'
  task :install, %i[bindir fmkdir] => :build do |task, args|
    (bindir, fmkdir) = Utils.defaults(args)
    generated_bundle_path = "#{BUILD_DIR}/Build/Products/#{RELEASE_CONFIGURATION}/sgen.app/Contents"

    Utils.print_header "Installing binary in #{bindir}"
    Utils.run([
                %(mkdir -p "#{bindir}"),
                %(cp -f "#{generated_bundle_path}/MacOS/sgen" "#{bindir}/#{BIN_NAME}")
              ], task, 'copy_binary')

    Utils.print_header "Installing frameworks in #{fmkdir}"
    Utils.run([
                %(if [ -d "#{fmkdir}" ]; then rm -rf "#{fmkdir}"; fi),
                %(mkdir -p "#{fmkdir}"),
                %(cp -fR "#{generated_bundle_path}/Frameworks/" "#{fmkdir}")
              ], task, 'copy_frameworks')

    Utils.print_header "Fixing binary's @rpath"
    Utils.run([
                %(install_name_tool -delete_rpath "@executable_path/../Frameworks" "#{bindir}/#{BIN_NAME}"),
                %(install_name_tool -add_rpath "@executable_path/#{fmkdir.relative_path_from(bindir)}" "#{bindir}/#{BIN_NAME}")
              ], task, 'fix_rpath', xcrun: true)

    Utils.print_info "Finished installing. Binary is available in: #{bindir}"
  end

  desc "Delete the build directory\n" \
     "(#{BUILD_DIR})"
  task :clean do
    sh %(rm -fr #{BUILD_DIR})
  end
end

## [ Release a new version ] ##################################################

namespace :release do
  desc 'Create a new release'
  task :new => [:check_versions, :confirm, 'xcode:test', :save]

  desc 'Check if all versions from the podspecs'
  task :check_versions do
    results = []

    Utils.table_header('Check', 'Status')

    # Check if bundler is installed first, as we'll need it for the cocoapods task (and we prefer to fail early)
    results << Utils.table_result(
      Open3.capture3('which', 'bundler')[2].success?,
      'Bundler installed',
      'Please install bundler using `gem install bundler` and run `bundle install` first.'
    )

    # Extract version from SGen.podspec
    sg_version = Utils.podspec_version('SGen')
    Utils.table_info('SGen.podspec', sg_version)

    # Check if version matches the SGen-Info.plist
    sg_plist = Utils.plist_version('SGen')
    results << Utils.table_result(
      sg_version == sg_plist[0] && sg_plist[0] == sg_plist[1],
      'SGen-Info.plist version matches',
      'Please update the version numbers in the SGen-Info.plist file'
    )

    exit 1 unless results.all?
  end

  task :confirm do
    version = Utils.podspec_version('SGen')
    print "Release version #{version} [Y/n]? "
    exit 2 unless STDIN.gets.chomp == 'Y'
  end

  desc 'Create a zip containing all the prebuilt binaries'
  task :zip => ['cli:clean', 'cli:install'] do
    `cp README.md build/sgen`
    `cd build/sgen; zip -r ../sgen-#{Utils.podspec_version('SGen')}.zip .`
  end

  desc 'Save the zipped binaries in the release folder'
  task :save => :zip do
    v = Utils.podspec_version('SGen')

    Utils.print_header "Saving release version #{v} on release folder"

    zipfile = "build/sgen-#{v}.zip"
    destpath = "#{RELEASE_DIR}/#{v}/sgen-#{v}.zip"
    FileUtils.mkdir_p(File.dirname(destpath))
    FileUtils.cp(zipfile, destpath)
  end
end

namespace :xcode do
  desc 'Build using Xcode'
  task :build do |task|
    Utils.print_header 'Compile using Xcode'
    Utils.run(
      %(xcodebuild -workspace "#{WORKSPACE}.xcworkspace" -scheme "#{SCHEME_NAME}" -configuration "#{CONFIGURATION}" build-for-testing),
      task,
      xcrun: true,
      formatter: :xcpretty
    )
  end

  desc 'Run Xcode Unit Tests'
  task :test => :build do |task|
    Utils.print_header 'Run the unit tests using Xcode'
    Utils.run(
      %(xcodebuild -workspace "#{WORKSPACE}.xcworkspace" -scheme "#{SCHEME_NAME}" -configuration "#{CONFIGURATION}" test-without-building),
      task,
      xcrun: true,
      formatter: :xcpretty
    )
  end
end

task :default => 'release:new'