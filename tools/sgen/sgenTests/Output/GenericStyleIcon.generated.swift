/// Autogenerated file

// swiftlint:disable all
import UIKit

@objc public extension S {

@objc enum IconSymbol: Int, Equatable {
	case none = -1
	case add = 0
	case alert
}

@objc enum IconSymbolSize: Int, Equatable {
	case large = 0
	case normal
	case small
}

@objc enum IconSymbolStyle: Int, Equatable {
	case filled = 0
	case regular
}

}
/// Entry point for the app stylesheet
@objc extension GenericStyle {

	//MARK: - IconEnums
	@objc(IconEnumsAppearanceProxy) @objcMembers open class IconEnumsAppearanceProxy: NSObject {
		public let mainProxy: () -> GenericStyle
		public init(proxy: @escaping () -> GenericStyle) {
			self.mainProxy = proxy
		}
	}
	//MARK: - IconMappings
	@objc(IconMappingsAppearanceProxy) @objcMembers open class IconMappingsAppearanceProxy: NSObject {
		public let mainProxy: () -> GenericStyle
		public init(proxy: @escaping () -> GenericStyle) {
			self.mainProxy = proxy
		}

		//MARK: - size
		public var _size: sizeAppearanceProxy?
		open func sizeStyle() -> sizeAppearanceProxy {
			if let override = _size { return override }
				return sizeAppearanceProxy(proxy: mainProxy)
			}
		public var size: sizeAppearanceProxy {
			get { return self.sizeStyle() }
			set { _size = newValue }
		}
		@objc(IconMappingsSizeAppearanceProxy) @objcMembers open class sizeAppearanceProxy: NSObject {
			public let mainProxy: () -> GenericStyle
			public init(proxy: @escaping () -> GenericStyle) {
				self.mainProxy = proxy
			}

			//MARK: large 
			public var _large: Int?
			open func largeProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> Int {
				if let override = _large { return override }
					return Int(32)
				}
			public var large: Int {
				get { return self.largeProperty() }
				set { _large = newValue }
			}

			//MARK: normal 
			public var _normal: Int?
			open func normalProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> Int {
				if let override = _normal { return override }
					return Int(24)
				}
			public var normal: Int {
				get { return self.normalProperty() }
				set { _normal = newValue }
			}

			//MARK: small 
			public var _small: Int?
			open func smallProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> Int {
				if let override = _small { return override }
					return Int(12)
				}
			public var small: Int {
				get { return self.smallProperty() }
				set { _small = newValue }
			}
		}

	}
	//MARK: - IconDefaults
	@objc(IconDefaultsAppearanceProxy) @objcMembers open class IconDefaultsAppearanceProxy: NSObject {
		public let mainProxy: () -> GenericStyle
		public init(proxy: @escaping () -> GenericStyle) {
			self.mainProxy = proxy
		}

		//MARK: size 
		public var _size: S.IconSymbolSize?
		open func sizeProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> S.IconSymbolSize {
			if let override = _size { return override }
			return S.IconSymbolSize.normal
			}
		public var size: S.IconSymbolSize {
			get { return self.sizeProperty() }
			set { _size = newValue }
		}

		//MARK: style 
		public var _style: S.IconSymbolStyle?
		open func styleProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> S.IconSymbolStyle {
			if let override = _style { return override }
			return S.IconSymbolStyle.regular
			}
		public var style: S.IconSymbolStyle {
			get { return self.styleProperty() }
			set { _style = newValue }
		}
	}

}
//MARK: - UIImage

private class IconsBundleCheck {}

@objc public extension UIImage {
	
	private static let iconBundle = Bundle(for: IconsBundleCheck.self)
	
	convenience init(icon: S.IconSymbol) {
		self.init(icon: icon, size: StylesheetManager.S.IconDefaults.size, style: StylesheetManager.S.IconDefaults.style)
	}
	
	convenience init(icon: S.IconSymbol, size: S.IconSymbolSize = StylesheetManager.S.IconDefaults.size) {
		self.init(icon: icon, size: size, style: StylesheetManager.S.IconDefaults.style)
	}
	
	convenience init(icon: S.IconSymbol, style: S.IconSymbolStyle = StylesheetManager.S.IconDefaults.style) {
		self.init(icon: icon, size: StylesheetManager.S.IconDefaults.size, style: style)
	}
	
	convenience init(icon: S.IconSymbol, size: S.IconSymbolSize = StylesheetManager.S.IconDefaults.size, style: S.IconSymbolStyle = StylesheetManager.S.IconDefaults.style) {
		self.init(named: icon.resourceString(size: size, style: style), in: UIImage.iconBundle, compatibleWith: nil)!
	}
	
}

//MARK: - S.IconSymbolSize

fileprivate extension S.IconSymbolSize {
	var resourceString: String {
		switch self {
		case .small: return "12"
		case .normal: return "24"
		case .large: return "32"
		}
	}
	var size: CGFloat {
		return CGFloat(Float(resourceString)!)
	}
}

//MARK: - S.IconSymbolStyle

fileprivate extension S.IconSymbolStyle {
	var resourceString: String {
		switch self {
		case .regular: return "regular"
		case .filled: return "filled"
		}
	}
}

//MARK: - S.IconSymbol 

extension S.IconSymbol {

	public var glyph: UIImage {
		return glyph()
	}
	
	public func glyph(_ size: S.IconSymbolSize = StylesheetManager.S.IconDefaults.size, style: S.IconSymbolStyle = StylesheetManager.S.IconDefaults.style)) -> UIImage {
		return UIImage(icon: self, size: size, style: style)
	}
	
	public var isValid: Bool {
		return self != S.IconSymbol.none
	}
	
	fileprivate func resourceString(size: S.IconSymbolSize = .normal, style: S.IconSymbolStyle = .regular) -> String {
		let safeSize: S.IconSymbolSize = availableSizes.enumerated().min(by: { abs($0.1.size - size.size) < abs($1.1.size - size.size) })?.element ?? StylesheetManager.S.IconDefaults.size
		let safeStyle: S.IconSymbolStyle = availableStyles.contains(style) ? style : (availableStyles.count == 1 ? availableStyles.first! :  StylesheetManager.S.IconDefaults.style)
		return "ic_fluent_\(name)_\(safeSize.resourceString)_\(safeStyle.resourceString)"
	}

	private var availableSizes: [S.IconSymbolSize] {
		switch self {
		case .add: return [.normal, .small]
		case .alert: return [.normal]
		case .none: fatalError("Icon not supported")
		default: break
		}
		// Swift compiler cannot check this enum is exhaustive without breaking it up
		// into smaller buckets
		// https://bugs.swift.org/browse/SR-11533
		fatalError("Icon not supported")
	}

	private var availableStyles: [S.IconSymbolStyle] {
		switch self {
		case .add: return [.filled, .regular]
		case .alert: return [.filled, .regular]
		case .none: fatalError("Icon not supported")
		default: break
		}
		// Swift compiler cannot check this enum is exhaustive without breaking it up
		// into smaller buckets
		// https://bugs.swift.org/browse/SR-11533
		fatalError("Icon not supported")
	}

	public var name: String {
		switch self {
		case .add: return "add"
		case .alert: return "alert"
		default: break
		}
		// Swift compiler cannot check this enum is exhaustive without breaking it up
		// into smaller buckets
		// https://bugs.swift.org/browse/SR-11533
		fatalError("Icon not supported")
	}
	
	public static var allCases: [(name: String, icon: S.IconSymbol, sizes: [S.IconSymbolSize], styles: [S.IconSymbolStyle])] {
	  [
		(name: "add", icon: .add, sizes: [.normal, .small], styles: [.filled, .regular]),
		(name: "alert", icon: .alert, sizes: [.normal], styles: [.filled, .regular])
	  ]
	}
}
