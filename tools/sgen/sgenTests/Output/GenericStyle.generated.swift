/// Autogenerated file

// swiftlint:disable all
import UIKit

public class Application {
	@objc dynamic public class func preferredContentSizeCategory() -> UIContentSizeCategory {
		return .large
	}
}

/// Your view should conform to 'AppearaceProxyComponent'.
public protocol AppearaceProxyComponent: class {
	associatedtype ApperanceProxyType
	var appearanceProxy: ApperanceProxyType { get }
	var themeAware: Bool { get set }
	func didChangeAppearanceProxy()
}

public extension AppearaceProxyComponent {
	func initAppearanceProxy(themeAware: Bool = true) {
		self.themeAware = themeAware
		didChangeAppearanceProxy()
	}
}

private extension S.FontTextStyle {
	var style: UIFont.TextStyle? {
		switch self {
			case .body: return .body
			case .callout: return .callout
			case .caption1: return .caption1
			case .caption2: return .caption2
			case .footnote: return .footnote
			case .headline: return .headline
			case .largeTitle:
				if #available(iOS 11.0, *) {
					return .largeTitle
				} else {
					 return nil
				}
			case .subheadline: return .subheadline
			case .title1: return .title1
			case .title2: return .title2
			case .title3: return .title3
		}
	}
	var defaultPointSize: CGFloat {
		switch self {
			case .body: return 17
			case .callout: return 16
			case .caption1: return 12
			case .caption2: return 11
			case .footnote: return 13
			case .headline: return 17
			case .largeTitle: return 34
			case .subheadline: return 15
			case .title1: return 28
			case .title2: return 22
			case .title3: return 20
		}
	}
	var maximumPointSize: CGFloat? {
		switch self {
			case .body: return 21
			case .callout: return 20
			case .caption1: return 16
			case .caption2: return 15
			case .footnote: return 17
			case .headline: return 21
			case .largeTitle: return 38
			case .subheadline: return 19
			case .title1: return 32
			case .title2: return 26
			case .title3: return 24
		}
	}
}

private let defaultSizes: [UIFont.TextStyle: CGFloat] = {
	var sizes: [UIFont.TextStyle: CGFloat] = [.caption2: 11,
	.caption1: 12,
	.footnote: 13,
	.subheadline: 15,
	.callout: 16,
	.body: 17,
	.headline: 17,
	.title3: 20,
	.title2: 22,
	.title1: 28]
	if #available(iOS 11.0, *) {
		sizes[.largeTitle] = 34
	}
	return sizes
}()

fileprivate class StardustFontResponsibleCache: NSObject {
	private lazy var cache = [UIFont.FontType: UIFont]()
	override init() {
		super.init()
		NotificationCenter.default.addObserver(self, selector: #selector(handleApplicationDidReceiveMemoryWarning), name: UIApplication.didReceiveMemoryWarningNotification, object: nil)
	}
	open func clearCache() {
		cache.removeAll()
	}
	@objc private func handleApplicationDidReceiveMemoryWarning() {
		clearCache()
	}
	func font(name: String? = nil, size: CGFloat? = nil, textStyle: S.FontTextStyle? = nil, weight: UIFont.Weight? = nil, traits: UIFontDescriptor.SymbolicTraits, traitCollection: UITraitCollection? = nil, isScalable: Bool = true) -> UIFont {
		let key = UIFont.FontType(name: name, size: size, textStyle: textStyle, weight: weight, traits: traits, traitCollection: traitCollection, isScalable: isScalable)
		if let font = cache[key] {
			return font
		} else {
			var font: UIFont!
			var isAlreadyScalable: Bool = false
			if let name = name, size != nil || textStyle != nil {
				if let size = size, let customFont = UIFont(name: name, size: size) {
					font = customFont
				} else if let textStyle = textStyle, let nativeTextStyle = textStyle.style {
					if #available(iOS 11.0, *) {
						if let customFont = UIFont(name: name, size: textStyle.defaultPointSize) {
							font = customFont
						}
					} else {
						let fontDescriptor = UIFontDescriptor.preferredFontDescriptor(withTextStyle: nativeTextStyle, compatibleWith: traitCollection)
						let max = textStyle.maximumPointSize ?? CGFloat.greatestFiniteMagnitude
						font = UIFont(name: name, size: min(fontDescriptor.pointSize, max))
					}
				}
			} else if let size = size {
				if let weight = weight {
					font = UIFont.systemFont(ofSize: size, weight: weight)
				} else {
					font = UIFont.systemFont(ofSize: size)
				}
			} else if let textStyle = textStyle, let nativeTextStyle = textStyle.style {
				if let weight = weight {
					if #available(iOS 11.0, *) {
						font = UIFont.systemFont(ofSize: textStyle.defaultPointSize, weight: weight)
					} else {
						let desc = UIFontDescriptor.preferredFontDescriptor(withTextStyle: nativeTextStyle, compatibleWith: traitCollection)
						let max = textStyle.maximumPointSize ?? CGFloat.greatestFiniteMagnitude
						font = UIFont.systemFont(ofSize: min(desc.pointSize, max), weight: weight)
					}
				} else {
					if let maximumPointSize = textStyle.maximumPointSize {
						if #available(iOS 11.0, *) {
							font = UIFont.preferredFont(forTextStyle: nativeTextStyle, compatibleWith: UITraitCollection(preferredContentSizeCategory: .large))
						} else {
							isAlreadyScalable = true
							let fontDescriptor = UIFontDescriptor.preferredFontDescriptor(withTextStyle: nativeTextStyle, compatibleWith: UITraitCollection(preferredContentSizeCategory: .large))
							font = UIFont(descriptor: fontDescriptor, size: min(fontDescriptor.pointSize, maximumPointSize))
						}
					} else {
						isAlreadyScalable = true
						font = UIFont.preferredFont(forTextStyle: nativeTextStyle, compatibleWith: traitCollection)
					}
				}
			}
			guard font != nil else { fatalError("Failed to load the font.") }
			if traits.isEmpty == false { font = font.with(traits: traits) }
			if isScalable && isAlreadyScalable == false {
				if #available(iOS 11.0, *) {
					if let nativeTextStyle = textStyle?.style {
						if let maximumPointSize = textStyle?.maximumPointSize {
							font = UIFontMetrics(forTextStyle: nativeTextStyle).scaledFont(for: font, maximumPointSize: maximumPointSize, compatibleWith: traitCollection)
						} else {
							font = UIFontMetrics(forTextStyle: nativeTextStyle).scaledFont(for: font, compatibleWith: traitCollection)
						}
					} else {
						font = UIFontMetrics.default.scaledFont(for: font, compatibleWith: traitCollection)
					}
				}
			}
			font.isScalable = isScalable
			font.fontType = key
			cache[key] = font
			return font
		}
	}
}

fileprivate var __FontTypeHandle: UInt8 = 0
fileprivate extension UIFont {
	struct FontType: Hashable {
		let name: String?
		let size: CGFloat?
		let textStyle: S.FontTextStyle?
		let weight: UIFont.Weight?
		let traits: UIFontDescriptor.SymbolicTraits
		let traitCollection: UITraitCollection?
		let isScalable: Bool
		func hash(into hasher: inout Hasher) {
			hasher.combine(name)
			hasher.combine(size)
			hasher.combine(textStyle)
			hasher.combine(weight)
			hasher.combine(traits.rawValue)
			hasher.combine(traitCollection)
			hasher.combine(isScalable)
		}
	}
	var fontType: FontType? {
		get { return objc_getAssociatedObject(self, &__FontTypeHandle) as? FontType }
		set { objc_setAssociatedObject(self, &__FontTypeHandle, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC) }
	}
}

fileprivate var __ScalableHandle: UInt8 = 0
public extension UIFont {
	private static var cache = StardustFontResponsibleCache()
	func with(traits: UIFontDescriptor.SymbolicTraits) -> UIFont {
		let descriptor = fontDescriptor.withSymbolicTraits(traits)
		return UIFont(descriptor: descriptor!, size: 0)
	}

	class func font(name: String? = nil, size: CGFloat? = nil, textStyle: S.FontTextStyle? = nil, weight: UIFont.Weight? = nil, traits: UIFontDescriptor.SymbolicTraits, traitCollection: UITraitCollection? = nil, isScalable: Bool = true) -> UIFont {
		return cache.font(name: name, size: size, textStyle: textStyle, weight: weight, traits: traits, traitCollection: traitCollection, isScalable: isScalable)
	}

	convenience init?(name: String, scalable: Bool) {
		self.init(name: name, size: 4)
		self.isScalable = scalable
	}

	var isScalable: Bool {
		get { return objc_getAssociatedObject(self, &__ScalableHandle) as? Bool ?? false }
		set { objc_setAssociatedObject(self, &__ScalableHandle, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC) }
	}

	var textStyle: UIFont.TextStyle? {
		return fontDescriptor.fontAttributes[.textStyle] as? UIFont.TextStyle
	}

	var fixedFont: UIFont {
		if isScalable == false { return self }
		if let fontType = fontType {
			return UIFont.font(name: fontType.name, size: fontType.size, textStyle: fontType.textStyle, weight: fontType.weight, traits: fontType.traits, traitCollection: fontType.traitCollection, isScalable: false)
		}
		guard let textStyle = textStyle, let defaultSize = defaultSizes[textStyle] else { return self }
		let fontDescriptor = UIFontDescriptor.preferredFontDescriptor(withTextStyle: textStyle)
		return UIFont(descriptor: fontDescriptor, size: defaultSize)
	}

}

public extension Notification.Name {
	static let didChangeTheme = Notification.Name("Stardust.stylesheet.theme")
}

protocol StylesheetManagerTheming {
	static func currentTheme() -> GenericStyle
	func themeInit()
}

extension StylesheetManagerTheming {
	static func currentTheme() -> GenericStyle {
		return GenericStyle.shared()
	}
	func themeInit() {
		
	}
}

@objcMembers public class StylesheetManager: NSObject, StylesheetManagerTheming {
	dynamic public class func stylesheet(_ stylesheet: GenericStyle) -> GenericStyle {
		return currentTheme()
	}

	public static let `default` = StylesheetManager()
	public static var S: GenericStyle {
		return currentTheme()
	}

	private override init() {
		super.init()
		themeInit()
	}
}

@objc(S) public class S: NSObject {

@objc public enum FontTextStyle: Int, Equatable {
	case body = 0
	case callout
	case caption1
	case caption2
	case footnote
	case headline
	case largeTitle
	case subheadline
	case title1
	case title2
	case title3
}

}
/// Entry point for the app stylesheet
@objc(STRGenericStyle) @objcMembers public class GenericStyle: NSObject {

	public class func shared() -> GenericStyle {
		 struct __ { static let _sharedInstance = GenericStyle() }
		return __._sharedInstance
	}
	//MARK: - Color
	public var _Color: ColorAppearanceProxy?
	open func ColorStyle() -> ColorAppearanceProxy {
		if let override = _Color { return override }
			return ColorAppearanceProxy(proxy: { return GenericStyle.shared() })
		}
	public var Color: ColorAppearanceProxy {
		get { return self.ColorStyle() }
		set { _Color = newValue }
	}
	@objc(ColorAppearanceProxy) @objcMembers open class ColorAppearanceProxy: NSObject {
		public let mainProxy: () -> GenericStyle
		public init(proxy: @escaping () -> GenericStyle) {
			self.mainProxy = proxy
		}

		//MARK: test 
		public var _test: UIColor?
		open func testProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> UIColor {
			if let override = _test { return override }
			return UIColor(red: 1.0, green: 1.0, blue: 1.0, alpha: 1.0)
			}
		public var test: UIColor {
			get { return self.testProperty() }
			set { _test = newValue }
		}
	}
	//MARK: - EmptyListView
	public var _EmptyListView: EmptyListViewAppearanceProxy?
	open func EmptyListViewStyle() -> EmptyListViewAppearanceProxy {
		if let override = _EmptyListView { return override }
			return EmptyListViewAppearanceProxy(proxy: { return GenericStyle.shared() })
		}
	public var EmptyListView: EmptyListViewAppearanceProxy {
		get { return self.EmptyListViewStyle() }
		set { _EmptyListView = newValue }
	}
	//MARK: - IconDefaults
	public var _IconDefaults: IconDefaultsAppearanceProxy?
	open func IconDefaultsStyle() -> IconDefaultsAppearanceProxy {
		if let override = _IconDefaults { return override }
			return IconDefaultsAppearanceProxy(proxy: { return GenericStyle.shared() })
		}
	public var IconDefaults: IconDefaultsAppearanceProxy {
		get { return self.IconDefaultsStyle() }
		set { _IconDefaults = newValue }
	}
	//MARK: - IconEnums
	public var _IconEnums: IconEnumsAppearanceProxy?
	open func IconEnumsStyle() -> IconEnumsAppearanceProxy {
		if let override = _IconEnums { return override }
			return IconEnumsAppearanceProxy(proxy: { return GenericStyle.shared() })
		}
	public var IconEnums: IconEnumsAppearanceProxy {
		get { return self.IconEnumsStyle() }
		set { _IconEnums = newValue }
	}
	//MARK: - IconMappings
	public var _IconMappings: IconMappingsAppearanceProxy?
	open func IconMappingsStyle() -> IconMappingsAppearanceProxy {
		if let override = _IconMappings { return override }
			return IconMappingsAppearanceProxy(proxy: { return GenericStyle.shared() })
		}
	public var IconMappings: IconMappingsAppearanceProxy {
		get { return self.IconMappingsStyle() }
		set { _IconMappings = newValue }
	}
	//MARK: - InnerEmptyListView
	public var _InnerEmptyListView: InnerEmptyListViewAppearanceProxy?
	open func InnerEmptyListViewStyle() -> InnerEmptyListViewAppearanceProxy {
		if let override = _InnerEmptyListView { return override }
			return InnerEmptyListViewAppearanceProxy(proxy: { return GenericStyle.shared() })
		}
	public var InnerEmptyListView: InnerEmptyListViewAppearanceProxy {
		get { return self.InnerEmptyListViewStyle() }
		set { _InnerEmptyListView = newValue }
	}
	@objc(InnerEmptyListViewAppearanceProxy) @objcMembers open class InnerEmptyListViewAppearanceProxy: EmptyListViewAppearanceProxy {

		//MARK: - InnerEmptyListViewcolor
		override open func colorStyle() -> EmptyListViewAppearanceProxy.colorAppearanceProxy {
			if let override = _color { return override }
				return InnerEmptyListViewcolorAppearanceProxy(proxy: mainProxy)
			}
		@objc(InnerEmptyListViewColorAppearanceProxy) @objcMembers open class InnerEmptyListViewcolorAppearanceProxy: EmptyListViewAppearanceProxy.colorAppearanceProxy {

			//MARK: normal 
			override open func normalProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> UIColor {
				if let override = _normal { return override }
					return UIColor(red: 0.8, green: 0.8, blue: 0.8, alpha: 1.0)
				}
		}

	}
	//MARK: - __TextStyle
	public var ___TextStyle: __TextStyleAppearanceProxy?
	open func __TextStyleStyle() -> __TextStyleAppearanceProxy {
		if let override = ___TextStyle { return override }
			return __TextStyleAppearanceProxy(proxy: { return GenericStyle.shared() })
		}
	public var __TextStyle: __TextStyleAppearanceProxy {
		get { return self.__TextStyleStyle() }
		set { ___TextStyle = newValue }
	}
	@objc(__TextStyleAppearanceProxy) @objcMembers open class __TextStyleAppearanceProxy: NSObject {
		public let mainProxy: () -> GenericStyle
		public init(proxy: @escaping () -> GenericStyle) {
			self.mainProxy = proxy
		}
	}

}